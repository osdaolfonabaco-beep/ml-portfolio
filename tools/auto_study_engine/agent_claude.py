"""
Módulo agent_claude.py
Generador de flashcards educativas a partir de código Python usando Claude AI.

Este módulo proporciona funcionalidades para analizar código Python y generar
flashcards educativas que ayuden a comprender los conceptos más importantes
del código analizado.
"""

import os
import json
import logging
import re

# Set up logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

def debug_file_paths(source_path):
    """Debug function to check file paths"""
    logger.debug(f"Source path: {source_path}")
    logger.debug(f"Absolute source path: {os.path.abspath(source_path)}")
    logger.debug(f"File exists: {os.path.exists(source_path)}")
    
    if os.path.exists(source_path):
        logger.debug(f"File size: {os.path.getsize(source_path)} bytes")

def _simular_respuesta_claude(code_content):
    """
    Simulate Claude AI response for flashcard generation.
    In production, this will be replaced with actual API calls.
    """
    try:
        # Analyze code content to generate relevant flashcards
        flashcards = []
        
        # Look for functions
        function_pattern = r"def\s+(\w+)\s*\([^)]*\)\s*:"
        functions = re.findall(function_pattern, code_content)
        
        for func in functions:
            flashcards.append({
                "question": f"What does the function '{func}' do?",
                "answer": f"The function '{func}' performs a specific operation. In a real implementation, this would be generated by Claude AI based on code analysis.",
                "category": "Functions",
                "difficulty": "medium"
            })
        
        # Look for classes
        class_pattern = r"class\s+(\w+)\s*(?:\([^)]*\))?\s*:"
        classes = re.findall(class_pattern, code_content)
        
        for cls in classes:
            flashcards.append({
                "question": f"What is the purpose of the class '{cls}'?",
                "answer": f"The class '{cls}' encapsulates related functionality. In a real implementation, Claude AI would provide a detailed explanation based on code analysis.",
                "category": "OOP",
                "difficulty": "medium"
            })
        
        # Look for imports
        import_pattern = r"import\s+(\w+)|from\s+(\w+)\s+import"
        imports = re.findall(import_pattern, code_content)
        
        for imp in imports:
            module = imp[0] or imp[1]
            flashcards.append({
                "question": f"What is the '{module}' module used for in this code?",
                "answer": f"The '{module}' module provides specific functionality. Claude AI would explain its purpose based on how it's used in the code.",
                "category": "Modules",
                "difficulty": "easy"
            })
        
        # Add some general programming concepts
        flashcards.extend([
            {
                "question": "What is the purpose of exception handling in Python?",
                "answer": "Exception handling allows programs to deal with unexpected situations gracefully using try-except blocks.",
                "category": "General",
                "difficulty": "easy"
            },
            {
                "question": "What are decorators in Python?",
                "answer": "Decorators are functions that modify the behavior of other functions or methods without directly changing their source code.",
                "category": "Advanced",
                "difficulty": "hard"
            }
        ])
        
        return flashcards
        
    except Exception as e:
        logger.error(f"Error in simulated Claude response: {e}")
        return []

def generate_flashcards_from_code(source_path):
    """
    Generate flashcards from Python source code.
    
    Args:
        source_path (str): Path to the Python source code file
        
    Returns:
        list: A list of flashcards generated from the code
    """
    try:
        # Debug file paths
        debug_file_paths(source_path)
        
        # Verify the file exists
        if not os.path.exists(source_path):
            logger.error(f"Source file does not exist: {source_path}")
            return []
        
        # Read the source code
        with open(source_path, 'r', encoding='utf-8') as f:
            code_content = f.read()
        
        logger.debug(f"Read {len(code_content)} characters from {source_path}")
        
        # Generate flashcards (simulated for now)
        flashcards = _simular_respuesta_claude(code_content)
        
        logger.debug(f"Generated {len(flashcards)} flashcards")
        
        return flashcards
        
    except Exception as e:
        logger.error(f"Error generating flashcards: {e}")
        return []